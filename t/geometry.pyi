from typing import Optional, overload, Tuple, Dict, Iterator
from enum import Enum

from .. import core
from .. import geometry

class Geometry:
    def __init__(self, *args, **kwargs) -> None: ...
    def clear(self) -> Geometry: ...
    def is_empty(self) -> bool: ...

class Image(Geometry):
    channels: int
    columns: int
    device: core.Device
    dtype: core.Dtype
    rows: int
    @overload
    def __init__(
        self,
        rows: int = 0,
        cols: int = 0,
        channels: int = 1,
        dtype: core.Dtype = core.Dtype.Float32,
        device: core.Device = core.Device("CPU:0"),
    ) -> None: ...
    @overload
    def __init__(self, tensor: core.Tensor) -> None: ...
    def as_tensor(self) -> core.Tensor: ...
    def clear(self) -> Image: ...
    def clip_transform(
        self, scale: float, min_value: float, max_value: float, clip_fill: float = 0.0
    ) -> Image: ...
    def clone(self) -> Image: ...
    def colorize_depth(
        self, scale: float, min_value: float, max_value: float
    ) -> Image: ...
    def cpu(self) -> Image: ...
    def create_normal_map(self, invalid_fill: float = 0.0) -> Image: ...
    def create_vertex_map(
        self, intrinsics: core.Tensor, invalid_fill: float = 0.0
    ) -> Image: ...
    def cuda(self, device_id: int = 0) -> Image: ...
    def dilate(self, kernel_size: int = 3) -> Image: ...
    def filter(self, kernel: core.Tensor) -> Image: ...
    def filter_bilateral(
        self, kernel_size: int = 3, value_sigma: float = 20.0, dist_sigma: float = 10.0
    ) -> Image: ...
    def filter_gaussian(self, kernel_size: int = 3, sigma: float = 1.0) -> Image: ...
    def filter_sobel(self, kernel_size: int = 3) -> Tuple[Image, Image]: ...
    @classmethod
    def from_legacy_image(
        cls, image_legacy: geometry.Image, device: core.Device = core.Device("CPU:0")
    ) -> Image: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def linear_transform(self, scale: float = 1.0, offset: float = 0.0) -> Image: ...
    def pyrdown(self) -> Image: ...
    def resize(
        self, sampling_rate: float = 0.5, interp_type: InterpType = InterpType.Nearest
    ) -> Image: ...
    def rgb_to_gray(self) -> Image: ...
    @overload
    def to(self, device: core.Device, copy: bool = False) -> Image: ...
    @overload
    def to(
        self,
        dtype: core.Dtype,
        scale: Optional[float] = None,
        offset: float = 0.0,
        copy: bool = False,
    ) -> Image: ...
    def to_legacy_image(self) -> geometry.Image: ...

class InterpType(Enum):
    Cubic = ...
    Lanczos = ...
    Linear = ...
    Nearest = ...
    Super = ...

class PointCloud(Geometry):
    point: TensorMap
    @overload
    def __init__(self, device: core.Device) -> None: ...
    @overload
    def __init__(self, points: core.Tensor) -> None: ...
    @overload
    def __init__(self, map_keys_to_tensors: Dict[str, core.Tensor]) -> None: ...
    def append(self, other: PointCloud) -> PointCloud: ...
    def clone(self) -> PointCloud: ...
    def cpu(self) -> PointCloud: ...
    @classmethod
    def create_from_depth_image(
        cls,
        depth: Image,
        intrinsics: core.Tensor,
        extrinsics: core.Tensor = ...,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        stride: int = 1,
        with_normals: bool = False,
    ) -> PointCloud: ...
    @classmethod
    def create_from_rgbd_image(
        cls,
        rgbd_image: RGBDImage,
        intrinsics: core.Tensor,
        extrinsics: core.Tensor = ...,
        depth_scale: float = 1000.0,
        depth_max: float = 3.0,
        stride: int = 1,
        with_normals: bool = False,
    ) -> PointCloud: ...
    def cuda(self, device_id: int = 0) -> PointCloud: ...
    @classmethod
    def from_legacy_pointcloud(
        cls,
        pcd_legacy: geometry.PointCloud,
        dtype: core.Dtype = core.Dtype.Float32,
        device: core.Device = core.Device("CPU:0"),
    ) -> PointCloud: ...
    def get_center(self) -> core.Tensor: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def rotate(self, R: core.Tensor, center: core.Tensor) -> PointCloud: ...
    def scale(self, scale: float, center: core.Tensor) -> PointCloud: ...
    def to(self, device: core.Device, copy: bool = False) -> PointCloud: ...
    def to_legacy_pointcloud(self) -> geometry.PointCloud: ...
    def transform(self, transformation: core.Tensor) -> PointCloud: ...
    def translate(
        self, translation: core.Tensor, relative: bool = True
    ) -> PointCloud: ...
    def voxel_down_sample(self, voxel_size: float) -> PointCloud: ...

class RGBDImage(Geometry):
    aligned_: bool
    color: Image
    depth: Image
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, color: Image, depth: Image, aligned: bool = True) -> None: ...
    def are_aligned(self) -> bool: ...
    def clear(self) -> RGBDImage: ...
    def clone(self) -> RGBDImage: ...
    def cpu(self) -> RGBDImage: ...
    def cuda(self, device_id: int = 0) -> RGBDImage: ...
    def get_max_bound(self) -> core.Tensor: ...
    def get_min_bound(self) -> core.Tensor: ...
    def to(self, device: core.Device, copy: bool = False) -> RGBDImage: ...
    def to_legacy_rgbd_image(self) -> geometry.RGBDImage: ...

class SurfaceMaskCode(Enum):
    ColorMap = ...
    DepthMap = ...
    NormalMap = ...
    VertexMap = ...

class TensorMap:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, primary_key: str) -> None: ...
    @overload
    def __init__(self, primary_key: str, map_keys_to_tensors: Dict[str, core.Tensor]) -> None: ...
    def assert_size_synchronized(self) -> None: ...
    def erase(self, key: str) -> int: ...
    def get_primary_key(self) -> str: ...
    def is_size_synchronized(self) -> bool: ...
    def items(self) -> Iterator: ...
